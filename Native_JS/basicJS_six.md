# 1 Что значит асинхронное действие?
1. [ ] Асинхронное действие - действие, при котором результат выполнения функции доступен спустя некоторое время (выполняется с задержкой). 
2. [ ] Запуск длительных операций происходит без ожидания их завершения и не блокирует дальнейшее выполнение программы.


# 2 Для чего нужны callback?
1. [ ] Callback-функции позволяют соблюдать последовательность выполнения функций.
2. [ ] Коллбэк должен быть выполнен после того, как другая функция завершит своё выполнение.
3. [ ] Коллбэк-функция ("функция обратного вызова") передаётся в параметр другой функции и вызывается в ней. 

# 3 Написать пример callback?
```js
1.
function printName(callback) {
    console.log("-Как тебя зовут?");
    callback();
}

printName(() => console.log("-Меня зовут Диана"));

2.
setTimeout(() => console.log("Hello"), 2000);
```


# Callback hell. Что это?
1. [ ] Есть ряд асинхронных задач, которые зависят друг от друга, т.е первая задача запускает по завершении 
2. [ ] вторую, вторая - третью и т.д. 
3. [ ] И мы получаем "башню" из обратных вызовов. 
4. [ ] Решают эту проблему Promise (промисы).      

Callback hell (ад коллбэков):
```js
setTimeout(() => {
    console.log(1);
    setTimeout(() => {
        console.log(2);
      setTimeout(() => {
        console.log(3);
        setTimeout(() => {
            console.log(4);
        }, 5000);
      }, 5000);
    }, 5000);
  }, 5000);
  ```

# 5 Промисы. Для чего нужны?
1. [ ] Промис - обещание предоставить результат позже.
2. [ ] Пример: отправив запрос на сервер, не знаем ответит или не ответит, какие данные пришлет, не знаем, какой будет результат запроса, но с помощью промиса мы можем поставить на ожидание получение результата и когда мы его получаем, то можем его обрабатывать. Промис может предоставить ошибку, если результат предоставить невозможно.
3. [ ] Промисы позволяют обрабатывать асинхронные операции (отложенные во времени события).


# 6 Что возвращает промис?
1. [ ] Промис может вернуть либо результат, либо ошибку.
```js
console.log(typeof Promise.resolve()); // object
```

# 7 Какие есть свойства у promise объекта?
1. state (состояние): когда промис создается у него будет состояние pending (ожидание) либо результата либо ошибки. Когда промис вернул какой-то результат он считается исполненным - fulfilled (выполнен успешно) при вызове resolve(), либо отклоненным - rejected (выполнен с ошибкой) при вызове reject().
3. result (результат): промис в состоянии ожидания имеет результат - undefined, когда промис успешно завершен его результатом является value при вызове resolve(), а если промис выполнился с ошибкой, то его результат - error при вызове reject(). 

# 8 Как создать промис?
```js
const myPromise = new Promise((resolve, reject) => {
        // выполнение асинхронных действий 
        // внутри этой функции нужно в результате вызвать одну из функций resolve() или reject()
});
```


# 9 Какие параметры есть у промиса?
1. Промис принимает коллбэк-функцию, которая имеет 2 параметра (resolve и reject- функции).
2. И мы внутри этой коллбэк-функции должны вызвать одну из этих 2 функций, чтобы промис завершился либо успехом, либо ошибкой.


# 10 Then, catch, finally
У объекта созданного через конструктор Promise доступны методы (then, catch, finally.
```js
const promise = new Promise((resolve, reject) => {
}).then(value => {
    // действия в случае успешного исполнения промиса 
    // значением value является значение, переданное в вызове функции resolve внутри промиса
}).catch(error => {
    // действия в случае отклонения промиса 
    // значением error является значение, переданное в вызове функции reject внутри промиса
}).finally(); // выполнится в любом случае, ничего не возвращает
```

# 11 Цепочка промисов. Что это и для чего?
1. [ ] Иногда количество асинхронных операций заранее неизвестно, но они должны выполняться строго по очереди.
2. [ ] Цепочка промисов это всегда then().then().then()
3. [ ] Единственный нюанс - начальный промис, с которого начинается строится цепочка. Если такого промиса нет, 
то его можно создать используя функцию Promise.resolve(). Он возвращает промис, который ничего не делает,
но с него можно начинать свёртку.
```js
Promise.reject("a")
        .catch(p => p + 'b') 
        .catch(p => p + 'c')
        .then(p => p + 'd')
        .finally(p => p + 'e')
        .then(p => console.log(p));
```

# 12 Promise.all
Метод Promise.all([]) возвращает промис, который выполнится тогда, когда будут выполнены все промисы, переданные в виде перечисляемого аргумента, или отклонено любое из переданных промисов.
```js
Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)])
       .then(value => console.log(value)); // [ 1, 2, 3 ]
```

# 13 Promise.race
Метод Promise.race() принимает несколько промисов, возвращает один из самых быстрозавершенных промисов
вне зависимости завершился он успешно или с ошибкой.
```js
Promise.race([Promise.resolve(1), Promise.resolve(2)])
       .then(value => console.log(value)); // 1
```

# 14 Microtask queue. Что это?
1. [ ] Обработчики промисов (then, catch, finally) всегда асинхронны. Когда промис выполнен код ниже обработчиков будет запущен первым.

```js
Promise.resolve("Промис выполнен").then(res => console.log(res));
console.log("Код выполнен");
```

5. [ ] Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь
PromiseJobs, более известную как "очередь микрозадач" - термин V8.

# 15 Правило FIFO
"Первым пришел - первым ушел" (first in first out)

# 16 Для чего ключевое слово async?
1. [ ] Ключевое слово async позволяет сделать из обычной функции асинхронную. 
2. [ ] Typeof от результата вызванной асинхронной функции - промис (object).
```js
async function foo() {

}

console.log(typeof foo()); // object
```

# 17 Для чего ключевое слово await?
1. [ ] Ключевое слово await заставляет движок JS приостановить выполнение кода на данной строке, позволяя 
выполняться другому коду, пока асинхронная функция не вернет результат. 
3. [ ] Как только она выполнится, код продолжит выполнение со следующей строки.

# 18 Что должно стоять справа от await?
promise

# 19 Ошибка в промисе с ключевым словом await
Для отлова ошибок используется конструкция try-catch.
```js
const promise = new Promise((res, rej) => {
    res(10);
})

async function getPromise() {
    try {
        const data = await promise;
        console.log(data)

    } catch(err) {
        console.log(err.message)
    }
}

getPromise()
```


# 20 Fetch. Для чего используется?
1. [ ] Fetch API позволяет JS обмениваться данными с сервером с помощью http-запросов и является более современной
заменой классу XMLHttpRequest. 
3. [ ] Выполнение запросов осуществляется методом fetch(), который возвращает промис.

# 21 Какие параметры у fetch?
```js
                    fetch(url, { options })
```
1. [ ] 1 параметр: url - URL для отправки запроса;
2. [ ] 2 параметр: options - параметры запроса. 
```
                    Список параметров:
```
* method - метод запроса (GET, POST, PUT, DELETE, HEAD);
* headers - HTTP-заголовки;
* body - тело запроса (используется при method: POST / PUT);
* cache - режим кэширования (default, reload, no-cache);
* mode - режим запроса (cors, no-cors, same-origin);
* redirect - указывает, как обрабатывать перенаправления(follow, error, manual);
* referrer - реферер запроса;
* signal - AbortSignal, прерывание запроса;
* credentials - отправка cookies вместе с запросом - mit, same-origin.

# 22 Post запрос. Как отправить? Написать
```js
fetch('https://jsonplaceholder.typicode.com/users', {
    method: 'POST',
    headers: {
    'Content-Type': 'application/json'
},
});
```

# 23 Get запрос. Как отправить? Написать
```js
fetch('https://jsonplaceholder.typicode.com/users');
```

# 24 Как прочитать тело ответа?
```js
     Метод fetch() возвращает Promise объект класса Response, который имеет следующие свойства:
```
* status - код ответа;
* statusText - текстовое сообщение, соответствующее коду ответа;
* ok - логическое значение, указывающее на успешность кода ответа (true: 200-299);
* headers - объект с заголовками ответа, в котором ключ - наименование заголовка, а значение ключа - значение соответствующего ключу заголовка;
* url - URL, на который был отправлен запрос;
* body - данные ответа в формате ReadableStream
* bodyUsed - логическое значение, указывающее на чтение данных.

# 25 response.json()

Переданные данные находятся в формате ReadableStream. Для изменения формата можно использовать следующие
методы:

* text() - преобразует ответ в строку;
* json() - преобразует ответ в формате JSON;
* blob() - преобразует ответ в объект Blob;
* formData() - конвертируется ответ в экземпляр FormData;
* arrayBuffer() - преобразует ответ в объект ArrayBuffer.

Пример преобразование ответа в формат JSON:
```js
fetch('https://jsonplaceholder.typicode.com/users')
  .then(response => response.json())
  .then(data => console.log(data));
```

# 26 Что такое коды статусов ответов?
1. [ ] Код статуса ответов представляет собой ответ сервера, который состоит из 3 цифр. 
2. [ ] Первая определяет класс ответа, а две другие указывают конкретный ответ. Означает, что запрос был успешно получен и идет его 
обработка.

# 27 На какие категории делятся коды статусов ответов?
Все коды делятся на 5 основных классов, каждый из которых обозначается первой цифрой кода:
* 1xx (Informational): информационные коды, которые указывают на то, что запрос был получен и 
продолжает обрабатываться.
* 2xx (Successful): коды, которые указывают на успешное завершение запроса.
* 3xx (Redirection): коды, которые требуют дополнительного действия от клиента, например, 
перенаправление на другой URL.
* 4xx (Client Error): коды, которые указывают на ошибку, вызванную некорректным запросом клиента.
* 5xx (Server Error): коды, которые указывают на ошибку на стороне сервера.

# 28 Какие коды статусов вы знаете? 2-3 из класса
Информационные:
* 100 Continue (продолжай)
* 101 Switching protocols (выбор протоколов)

Успешные:
* 200 Ok (успешно)
* 201 Created (создано)

Перенаправление:
* 300 Multiple Choice (множественный выбор)
* 301 Moved Permanently (перемещен на постоянной основе)

Ошибки на стороне клиента:
* 400 Bad request (плохой запрос)
* 401 Unauthorized (неавторизованно)
* 403 Forbidden (запрещено)
* 404 Not Found (не найден)
* 408 Request Timeout (время ожидания истекло)
* 418 I'm a teapot (я чайник)

Ошибки на стороне сервера:
* 500 Internal Server Error (внутренняя ошибка сервера)
* 503 Service Unavailable (сервис недоступен)
* 520 Unknown error (неизвестная ошибка)
* 521 Web server is down (веб-сервер не работает)

