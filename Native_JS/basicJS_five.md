# 1 Как объявить класс? Какие основные блоки есть?
Через ключевое слово class
```js
class myClass {
    // методы класса
    constructor() { 

    }
    method1() {

    }
    method2() {

    }
}
```
* Классы позволяют создавать прототипы для объектов.
* На основании прототипов создаются экземпляры.
* Экземпляры могут иметь собственные свойства и методы. Экземпляры наследуют свойства и методы 
* прототипов. 
* Синтаксис классов появился в ES6(2015)

# 2 Для чего нужен constructor()?
Метод constructor() вызывается автоматически, в нём инициализируется объект. 

# 3 Как работают классы под капотом? Что происходит при создании класса и объявлении методов?
В JS класс - разновидность функции. 
```js
class User {
    constructor(name) {
        this.name = name;
    }

    sayHi() {
        console.log(this.name);
    }
}

// доказательство: User - это функция
console.log(typeof User); // function
```
1. Вот что на самом деле делает конструкция class User {...}:
2. Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
4. Сохраняет все методы, такие как sayHi, в User.prototype.
5. При вызове метода объекта new User он будет взят из прототипа, как описано в главе F.prototype. Таким образом, объекты new User имеют доступ к методам класса.

# 4 Как вызвать созданный класс?
Использование:
```js
const user = new User("Иван");
user.sayHi();
```
Когда вызывается new User("Иван"):
* Создаётся новый объект.
* constructor запускается с заданным аргументом и сохраняет его в this.name.

# 5 Что возвращает вызов класса?
Новый объект (экземпляр класса)

# 6 Геттеры и сеттеры. Для чего?
* Геттеры и сеттеры – это специальные методы, доступ к которым осуществляется через связанное с каждым из них свойство. 
* При этом геттер работает при чтении свойства, а сеттер – при присвоении свойству некоторого значения. При написании геттера, его необходимо задавать соответственно без параметров, а сеттер – с одним параметром.
* Другими словами, геттер и сеттер позволяют создать на вид обычное свойство, но работающее через функции.
* Очень часто геттеры и сеттеры применяются соответственно для чтения приватных свойств и присвоения им новых значений.

# 7 Как создать свойство в классе?
```js
class Person {
    #name;
    #age;
    constructor(name, age) {
      this.#name = name;
      this.#age = age;
    }
    // геттер для получения имени
    get name() {
      return this.#name;
    }
    // геттер для получения возраста
    get age() {
      return this.#age;
    }
    // сеттер для установки возраста
    set age(value) {
      if (Number.isInteger(value) && value > 0) {
        return this.#age = value;
      }
      throw new Error('Ошибка при установке значения свойству #age! Значение не является целым положительным числом.');
    }
  }
```

# 8 Ключевое слово для наследования классов?
Наследование классов - способ расширения одного класса другим классом. Мы можем добавить новый функционал к уже существующему. 
Ключевое слово "extends".
```js
class User {

}

class Admin extends User {
    
}
```

# 9 Переопределение методов
Вся процедура переопределения написать метод с таким же именем в классе - в дочернем классе.
```js
class User {
    constructor(name) {
        this.name = name;
    }

    sayHi() {
        return this.name;
    }
}

class Admin extends User {
    constructor(name, isAdmin) {
        super(name);
        this.isAdmin = isAdmin;
    }
    sayHi() {
        return `${super.sayHi()} - ${this.isAdmin}`;
     }
}

const admin = new Admin("Diana", true);

console.log(admin.sayHi());
```

# 10 Ключевое слово super
В конструкторе ключевое слово super() используется как функция, вызывающая родительский конструктор. Ее необходимо вызвать до первого
обращения к ключевому слову this в теле конструктора.

# 11 Переопределение конструктора
* Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то создается автоматически "пустой" конструктор. 


* Конструкторы в наследуемых классах должны обязательно вызывать super() и делать это перед использованием this.
```js
class AnimaL {
  constructor(name) {
    this.name = name;
  }
}

class Rabbit extends AnimaL {
    constructor(name, speed) {
      super(name);
      this.speed = speed; 
    }
}
```

# 12 Какой конструктор создается по умолчанию у дочернего класса?
У дочернего класса нет конструктора своего. И чтоб передать дочернему новые свойства, нужна связь с родительским конструктором через super().

# 13 super в конструкторе
Используется в дочернем классе для вызова родительского конструктора. 

# 14 Статические методы и свойства
* static - определение статичных методов. Статические методы - функции, принадлежащие объекту класса, но
недоступные другим объектам того же класса.


* Статические методы вызываются через имя класса. Вызывать через имя объекта запрещено. Используется часто для создания вспомогательных функций приложений. 
```js
class Repo {
  static getName(name) {
      return name;
  }
}

console.log(Repo.getName("Yakov"));
```

# 15 Защищенные свойства. Для чего и как сделать свойство защищенным?
* Защищенные свойства - _IsAdmin = true (доступно и в классе и в экземпляре). Это договоренность между разработчиками, если свойство защищенное его лучше не изменять. Для таких свойств пишутся геттеры и сеттеры, которые изменяются
под капотом.


* Приватные свойства - #isAdmin = true. Они нужны только для использования внутри класса, где оно создано.
Обратиться в экземпляре к приватному свойству вызовет ошибку. Обратиться можно только внутри класса. 
```js
class Allo {
  #isAdmin = true

  sayAdmin() {
    return this.#isAdmin;
  }
}
 
const obj = new Allo();

console.log(obj.sayAdmin()); // true
```

# 16 Инкапсуляция
Инкапсуляция - объединение данных и методов, которые воздействуют на эти данные, так что доступ к этим данным ограничен извне (приватные свойства у класса).

# 17 instanceof
instanceof - проверяет принадлежность экземпляра к классу

```js
class Cat {

}

const catOne = new Cat();

console.log(catOne instanceof Cat); // true

console.log(catOne instanceof Object); // true
```

# 18 Для чего придумали примеси? Как реализовать?
* В JS можно наследоваться только от одного объекта. Объект имеет ед. [[Prototype]].
* И класс может расширить только один другой класс. 
* Примесь позволяет расширить функциональность классов через запись Object.assign(куда, что)

# 19 Множественное наследование в JavaScript 
В JS его нет. Проблему решают примеси. 
```js
class myClasses {

}

const obj = {
  a: 2
};

const obj2 = {
  sayHi() {
    return "Hello";
  }
};


Object.assign(myClass, obj, obj2); // подмешиваем свойства и методы; 1 параметр - куда копируем свойства
// и методы объекта, 2 парметр - что копируем

console.log(myClass.sayHi());
```


